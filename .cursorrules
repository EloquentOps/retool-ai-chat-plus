# Cursor Rules for Retool AI Chat Plus

## Project Overview
This is a Retool Custom Component Library for an AI Chat component with extensible widget system. The component supports both Retool AI Query and Retool Agent Query.

## Project Structure
- `src/components/` - Main React components (ChatContainer, MessageList, InputBar, etc.)
- `src/components/widgets/` - Core widgets (TextWidget only) and registry
- `src/components/widgets/external/` - External widgets (for testing, can be extracted to npm)
- `src/plugin-loader/` - Plugin system types and utilities
- `scripts/` - Build scripts including plugin builder
- `templates/widget-package/` - Template for creating npm widget packages
- `retool-widget-plugins.json` - Plugin configuration file
- `dist/` - Built output for Retool

## Widget Development Guidelines

### Widget Architecture
The widget system has three tiers:
1. **Core widgets** (`src/components/widgets/`) - Essential widgets like TextWidget
2. **External widgets** (`src/components/widgets/external/`) - Widgets in development or ready for extraction
3. **NPM plugins** (`node_modules/`) - Published widget packages

Widgets are auto-discovered by the build script. Configuration is in `retool-widget-plugins.json`.

### Creating a New Widget
1. Create widget file in `src/components/widgets/external/YourWidget.tsx`
2. Export both component and instruction from the file
3. Add widget name to `retool-widget-plugins.json` in the `external` array
4. Run `npm run build:plugins` to regenerate the registry

Example `retool-widget-plugins.json`:
```json
{
  "external": ["chart", "tabulator", "your_widget"],
  "plugins": []
}
```

### Widget Interface
```typescript
interface WidgetProps {
  source: string | object | array
  onWidgetCallback?: (payload: Record<string, unknown>) => void
  widgetsOptions?: Record<string, unknown>
  historyIndex?: number
}

interface WidgetInstruction {
  type: string
  instructions: string
  sourceDataModel: string | object
}
```

### Widget File Structure
```typescript
// src/components/widgets/external/YourWidget.tsx
import React from 'react'
import type { FC } from 'react'

interface YourWidgetProps {
  source: string | YourDataType
  onWidgetCallback?: (payload: Record<string, unknown>) => void
  widgetsOptions?: Record<string, unknown>
  historyIndex?: number
}

const YourWidgetComponent: FC<YourWidgetProps> = ({ source, onWidgetCallback, historyIndex }) => {
  // Implementation
  return <div>...</div>
}

// REQUIRED: Memoize to prevent re-renders during polling
export const YourWidget = React.memo(YourWidgetComponent, (prev, next) => {
  return JSON.stringify(prev.source) === JSON.stringify(next.source) &&
         prev.historyIndex === next.historyIndex
})

// REQUIRED: Export instruction for AI
export const YourWidgetInstruction = {
  type: 'your_widget',  // Must match the name in retool-widget-plugins.json
  instructions: 'When to use this widget...',
  sourceDataModel: { field: 'description' }
}
```

## Code Style & Conventions

### TypeScript
- Use TypeScript for all new code
- Prefer explicit types over `any`
- Use interfaces for props and data structures
- Export types when used across files

### React Patterns
- Use functional components with hooks
- Use `React.FC` type for component props
- Prefer named exports over default exports
- Use React.memo for ALL widgets (required for polling performance)

### File Naming
- Components: PascalCase (e.g., `ChatContainer.tsx`)
- Widgets: PascalCase with Widget suffix (e.g., `ChartWidget.tsx`)
- Utilities: camelCase (e.g., `widgetUtils.ts`)

### Widget Naming Convention
- File: `PascalCaseWidget.tsx` (e.g., `GoogleMapWidget.tsx`)
- Registry key: `snake_case` (e.g., `google_map`)
- Use the mapping in build script for special cases

## Key Dependencies
- React 18.2.0
- @tryretool/custom-component-support (latest)
- react-markdown for text rendering
- react-mentions for mention support
- echarts for charts
- tabulator-tables for tables
- @googlemaps/js-api-loader for maps

## Build Commands
- `npm run build:plugins` - Regenerate widget registry from config
- `npm run dev` - Start development server (auto-runs build:plugins)
- `npm run deploy` - Deploy to Retool (auto-runs build:plugins)

## Widget System Details
- Widgets are mentioned in chat input using `@widget_name` syntax
- Widget instructions are injected into AI prompts automatically
- Widgets can accept string, object, or array data
- Widget callbacks communicate user interactions back to chat system
- Widget options can override instructions and sourceDataModel per widget type

### Widget Callback Pattern
```typescript
onWidgetCallback?.({
  type: 'interaction_type',
  widgetType: 'your_widget',
  data: interactionData,
  historyIndex,
  timestamp: Date.now()
})
```

## Testing Considerations
- Widgets should handle missing or invalid data gracefully
- Always validate source data before rendering
- Provide fallback UI for error states
- Test with both AI Query and Agent Query formats
- Use `retool-widget-plugins.json` to test with subset of widgets

## Performance
- Use React.memo for ALL widget components (required!)
- Implement custom comparison function for complex data
- Avoid unnecessary re-renders during polling
- Clean up resources in useEffect cleanup functions

## Extracting Widget to NPM Package
When ready to publish a widget as a separate package:
1. Copy `templates/widget-package/` to a new repo
2. Move widget code from `external/` to the new package
3. Update `widget.manifest.json` with widget details
4. Publish to npm
5. Add package name to `plugins` array in config
6. Remove from `external` array

